package NowCoder;

import java.util.*;

/**
 * https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a
 * <p>
 * 纯数学题，思路与前面人的思路不太一样，不用借桃子，直接根据题意来进行求解，设最少需要桃子X个：
 * 第一次经过题目的处理剩余桃子数目为：4/5(X-1)=(4/5)*X-(4/5)；
 * 第二次剩余桃子个数为：4/5(4/5(X-1)-1)=((4/5)^2)*X-(4/5)^2-(4/5)；
 * 第三次剩余桃子个数为：4/5(4/5(4/5(X-1)-1)-1)=((4/5)^3)*X-(4/5)^3-(4/5)^2-(4/5)；
 * 依次类推，经过n只猴子的类似处理，剩余桃子数为：
 * 4/5(4/5(4/5(....(4/5(X-1)...)-1)-1)-1)=((4/5)^n)*X)-(4/5)^n-(4/5)^(n-1)-...-(4/5)
 * =((4/5)^n)*X)-4[1-(4/5)^n]
 * =(X+4)*(4/5)^n-4
 * 因此，同前人的推导一致，最终，只需要满足x+4的值为5^n次方则可以保证最后能得到一个整数，满足题目的要求
 * <p>
 * 链接：https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a
 * 来源：牛客网
 * <p>
 * 思路：因为每次分5堆都会多出来1个，所以我们借给猴子们4个，以致每次都可以刚好分成5堆
 * 并且，每次给老猴子的桃子都不在我们借出的那4个中，这样最后减掉4就可以得到结果。
 * 假设最初由x个桃子，我们借给猴子4个，则此时有x+4个，
 * 第一个猴子得到（x+4）/5，剩余（x+4）*（4/5）个
 * 第二个猴子分完后剩余（x+4）*(4/5)^2个
 * 第三个猴子分完后剩余（x+4）*(4/5)^3个
 * 依次类推，最后一个猴子分完后剩余（x+4）*（4/5）^n
 * 要满足最后剩余的为整数，并且x最小，则当 x+4=5^n时，满足要求
 * 此时，x=5^n-4;
 * 老猴子得到的数量为：old = （x+4）*（4/5）^n + n - 4
 * = 4^n + n - 4
 * 最后加n是因为不是剩余多出来的一个，而是小猴子给的，比如桃子是有6个，小猴子本身只能拿一个，我们借给4个，小猴就能拿两个，那多出来的哪一个给老猴子，和之前6个整除五余1一个道理
 * 最后老猴子减4是还给我们借给它们的那4个
 */
public class 猴子分桃 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = 0;
        while (sc.hasNext()) {
            n = sc.nextInt();
            if (n == 0)
                break;
            long a = (long) Math.pow(5, n);
            long b = (long) Math.pow(4, n);
            System.out.println((a - 4) + " " + (b - 4 + n));
        }
    }
}
