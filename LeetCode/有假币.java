package NowCoder;

import java.util.*;

/**
 * 链接：https://www.nowcoder.com/questionTerminal/1d18c0841e64454cbc3afaea05e2f63c
 * 来源：牛客网
 *
 * 一看到这道题，我首先想到的是一个猜数游戏，就是随机生成[1,1000]之间的一个数，你每次报错一个猜想值，只告诉你你猜的数是比随机数大还是小，
 * 每次根据反馈调整猜的数值，直到猜中为止。玩过的都知道，折半查找是最快的，比如将[1,1000]分为[1,500]、[500,1000]，第一次猜500，
 * 如果大了就猜250，否则猜750。这样按照折半的规则猜，最多需要 log2n向上取整次。
 *
 * 对于这道题，我已开始的思路也是折半查找，把n分成两堆，如果n不是偶数，就分成(n - 1) / 2。但这种思路并不是最优的，无法通过所有测试。
 * 我们首先来看前面几个示例：
 *
 * 当n = 1时，不需要再称了，它就是假币，总共需要0次
 * 当n = 2时，1、1放天平两端，轻的就是假币，总共需要1次
 * 当n = 3时，随机抽出2个放到天平两端，如果天平平衡，则剩下1个就是假币，
 *     否则天平中较轻的是假币，总共需要1次
 * 当n = 4时，分成1、1、2，天平秤1、1，注意题目要求最短时间，
 *     并且是次数最大的情况，也就是我们需要考虑最坏的情况，第一次1、1重量相等，
 *     接着我们把2分开称，总共需要2次
 * 当n = 5时，分成2、2、1，天平秤2、2，同样考虑最坏的情况，2、2重量相等，
 *     接着我们把2分开称，总共需要2次
 * 当n = 6时，分成2、2、2，天平秤2、2，同样考虑最坏的情况，不管如何，还需要
 *     把2分开称，总共需要2次
 * 当n = 7时，分成2、2、3，天平先称2、2，考虑最坏的情况，重量相等，接着我们就需要
 *     按照n = 3的最优情况称，总共需要2次
 * ...
 *
 * 其中有一个规则，我们每次把n分成是3堆，
 *     如果n % 3 == 0,分成 n/3、 n/3、 n/3三堆， 剩下 n/3
 *     如果n % 3 == 1,分成 n/3、 n/3、1 + (n/3)三堆，最坏剩下 1 + (n/3)
 *     如果n % 3 == 2,分成 n/3、 1 + (n/3)、1 + (n/3)三堆，最坏剩下 1 + (n/3)
 */

public class 有假币 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n != 0) {
            int count = 0;
            while (n > 1) {
                n = n / 3 + 1 - (n % 3 ^ 3) / 3;//如果n%3 == 0，那么就是和3去异或，就是3，一除就是1了，完美。
                count++;
            }
            System.out.println(count);
            n = sc.nextInt();
        }
    }
//    public static void main(String[] args) {
//        Scanner sc = new Scanner(System.in);
//        while (sc.hasNextLong()) {
//            long x = sc.nextLong();
//            if(x == 0){
//                return;
//            }
//            System.out.println(fun(x));
//        }
//    }
//
//    private static int fun(long x) {
//        int count = 0;
//        while (x != 1) {
//            if ((x & 1) == 1) {
//                x = (x - 1) / 2;
//            } else {
//                x = x / 2;
//            }
//            count++;
//        }
//        return count;
//    }
}
